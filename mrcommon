# ---------------------------------------------------------------------------- #
# Utility functions to handle arch linux package building and AUR downloads    #
# ---------------------------------------------------------------------------- #

lib=
        archdir="$AB2_ARCH_DIR"
        builddir="$HOME/opt/arch/build"
        if [ ! -d "$builddir" ]; then
            echo "ERROR: build directory does not exist. Please create it."
            echo "Path: $builddir"
            exit 1
        fi   
        # need to dereference symlinks, otherwise subtle crap may happen when building stuff.
        # for instance, emacs gets the autoloads paths wrong
        builddir="$(readlink -f $builddir)"
        commit_if_changes() {
            # commit_if_changes <path> <message>
            # Commits changes to a repo if there are any, otherwise do nothing.
            path="$1"
            message="$2"
            cd "$path"
            num=$(git status --porcelain | wc -l)
            if [[ $num -ge 1 ]]; then            
                git add -A .
            fi
            num=$(git status --porcelain | wc -l)
            if [[ $num -ge 1 ]]; then
                git commit -m "$message ($num files)"
            fi
        }
        pkgbuild_parse() {
            $archdir/pkgbuild-parse.sh "$@"
        }
        pkgbuild_package_file() {
            # pkgbuild_package_file <path>
            # echoes the full path of the package a build will generate
            path="$1"
            pkgfile=$(pkgbuild_parse "$path/PKGBUILD" pkgfile)
            echo "$path/$pkgfile"
        }
        pkgbuild_source_paths() {
            path="$1"
            pkgbuild_parse "$path/PKGBUILD" localsource
        }
        package_uptodate() {
            # package_uptodate <path>
            # Check whether the package is up to date.
            path="$1"
            pkgfile="$(pkgbuild_package_file $path)"
            if [ -z "$pkgfile" ]; then
                echo "An error occurred parsing the PKGBUILD"
                exit 1
            fi        
            [ -f  "$pkgfile" ]
        }
        builddir_path() {
            # builddir_path <path>
            # echoes the build directory path for a given package
            path="$1"
            pkgname=$(basename "$1")
            echo "$builddir/$pkgname"           
        }
        prepare_build() {
            # prepare_build <path>
            # Prepares a package for building on the builddir
            # returns the path where the building will occur
            path="$1"
            buildpath=$(builddir_path "$path")
            rsync -avz --exclude=.git "$path/" "$buildpath/" > /dev/null
            echo "$buildpath"            
        }
        package_build() {
            # package_build <path>
            # Build a package at the given directory.
            path="$1"
            cd "$path"
            makepkg -f --sign
        }
        package_download() {
            # package_download <path>
            # Download package sources.
            path="$1"
            cd "$path"
            makepkg --nobuild
        }
        package_install() {
            # package_install <path>
            # Install a package.
            path="$1"
            pkgname=$(basename "$path")
            pkgfile=$(pkgbuild_package_file "$path")
            if [ -f "$pkgfile" ]; then
                sudo pacman --noconfirm -U "file://$pkgfile"               
            fi             
        }
        package_install_deps() {
            # package_install_deps <path>
            # Install package deps.
            path="$1"
            cd "$path"
            makepkg -s
        }
        package_repoadd() {
            # package_repoadd <path>
            # Add package to the pacman repo and clean older versions of it.
            path="$1"
            tgtrepo="$2"
            pkgname=$(basename "$path")
            pkgfile=$(pkgbuild_package_file "$path")
            repodb=$(basename "$tgtrepo").db.tar.gz
            if [ -f "$pkgfile" ]; then
                # clean older packages
                rm -f $tgtrepo/$pkgname-*.pkg.tar.xz{,.sig}
                # copy package and signature
                cp "$pkgfile" "$tgtrepo/"
                cp "$pkgfile.sig" "$tgtrepo/"
                repo-add "$tgtrepo/$repodb" "$pkgfile"
            fi
        }
        package_repodel() {
            # package_repodel <path>
            # Delete a package from the repo.
            path="$1"
            tgtrepo="$2"
            pkgname=$(basename "$path")
            repodb=$(basename "$tgtrepo").db.tar.gz
            rm -f $tgtrepo/$pkgname-*.pkg.tar.xz{,.sig}
            repo-remove "$tgtrepo/$repodb" "$pkgname"
        }
        aur_checkout() {
            # aur_checkout <pkgname>
            # Checkout a PKGBUILD from AUR
            pkgname="$1"
            cower -df --ignorerepo "$pkgname"
            cd "$pkgname" && git init && git add -A . && git commit -m 'Initial commit'
        }
        aur_update() {
            # aur_update <path>
            # Update git repo with last PKGBUILD from AUR.                                   
            path="$1"
            pkgname=$(basename "$1")
            # NOTE: only update on branch master, to preserve possible local changes.
            if [ ! "$(git symbolic-ref HEAD 2>/dev/null)" == 'refs/heads/master' ]; then
                echo "Not on branch master"
                return 1
            fi              
            cower -df --ignorerepo "$pkgname" -t ..
            commit_if_changes "$path" "Updated from AUR"
        }

build= 
        buildpath=$(prepare_build "$PWD")
        pkgname=$(basename "$PWD")
        reponame="$(basename $(dirname $PWD))"
        # silent download for packages in devel
        if [ "$reponame" == 'devel' ]; then
            ( package_download "$buildpath" )  > /dev/null 2>&1 
        else               
            package_download "$buildpath"
        fi               
        if package_uptodate "$buildpath"; then
            echo "Package is up to date. No need to rebuild."
        else
            package_build "$buildpath"
        fi

rebuild= 
        buildpath=$(builddir_path "$PWD")
        [ -d "$buildpath" ] && rm -Rf "$buildpath"
        buildpath=$(prepare_build "$PWD")        
        package_build "$buildpath"

install= 
        buildpath=$(builddir_path "$PWD")
        package_install "$buildpath"

installdeps=
        package_install_deps "$buildpath"

update=
        mr build
        mr repoadd

