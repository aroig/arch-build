# ---------------------------------------------------------------------------- #
# Utility functions to handle arch linux package building and AUR downloads    #
# ---------------------------------------------------------------------------- #

# Some functions I stole from the pkgbuild script
lib=
        have_function() {
	    declare -f "$1" >/dev/null
        }
        ##
        #  usage : source_safe <pkgbuild>
        #   desc : source a file safely
        ##
        source_safe() {
            shopt -u extglob
            if ! source "$@"; then
                # NOTE: if source fails this does not get executed
                error "$(gettext "Failed to source %s")" "$1"
                exit 1
            fi
            shopt -s extglob
        }
        ##
        #  usage : run_function_safe <func>
        #   desc : run a function safely
        ##
        run_function_safe() {
            local restoretrap
            local pkgfunc="$1"
            set -e
            set -E
            restoretrap=$(trap -p ERR)
            trap 'error_function $pkgfunc' ERR
            $pkgfunc
            eval $restoretrap
            set +E
            set +e
        }
        ##
        #  usage : source_pkgbuild <pkgbuild>
        #   desc : source a PKGBUILD safely
        ##
        source_pkgbuild() {
            pkgbuild="$1"
            source_safe "$pkgbuild"
            pkgbase=${pkgbase:-${pkgname[0]}}
            srcdir="$path/src"
            pkgdir="$path/pkg/$pkgbase"
            epoch=${epoch:-0}
        }
        ##
        #  usage : get_full_version <pkgname>
        # return : full version spec, including epoch (if necessary), pkgver, pkgrel
        ##
        get_full_version() {
            if [[ -z $1 ]]; then
                if [[ $epoch ]] && (( ! $epoch )); then
                    printf "%s\n" "$pkgver-$pkgrel"
                else
                    printf "%s\n" "$epoch:$pkgver-$pkgrel"
                fi
            else
                for i in pkgver pkgrel epoch; do
                    local indirect="${i}_override"
                    eval $(declare -f package_$1 | sed -n "s/\(^[[:space:]]*$i=\)/${i}_override=/p")
                    [[ -z ${!indirect} ]] && eval ${indirect}=\"${!i}\"
                done
                if (( ! $epoch_override )); then
                    printf "%s\n" "$pkgver_override-$pkgrel_override"
                else
                    printf "%s\n" "$epoch_override:$pkgver_override-$pkgrel_override"
                fi
            fi
        }
        ##
        #  usage : get_pkg_arch <pkgname>
        # return : architecture of the package
        ##
        get_pkg_arch() {
            CARCH=x86_64
	    if [[ -z $1 ]]; then
                if [[ $arch = "any" ]]; then
                    printf "%s\n" "any"
                else
                    printf "%s\n" "$CARCH"
                fi
            else
                local arch_override
                eval $(declare -f package_$1 | sed -n 's/\(^[[:space:]]*arch=\)/arch_override=/p')
                (( ${#arch_override[@]} == 0 )) && arch_override=("${arch[@]}")
                if [[ $arch_override = "any" ]]; then
                    printf "%s\n" "any"
                else
                    printf "%s\n" "$CARCH"
                fi
            fi
        }


lib=
        builddir="$HOME/opt/arch/build"
        if [ ! -d "$builddir" ]; then
            echo "ERROR: build directory does not exist. Please create it."
            echo "Path: $builddir"
            exit 1
        fi   
        # need to dereference symlinks, otherwise subtle crap may happen when building stuff.
        # for instance, emacs gets the autoloads paths wrong
        builddir="$(readlink -f $builddir)"
        commit_if_changes() {
            # commit_if_changes <path> <message>
            # Commits changes to a repo if there are any, otherwise do nothing.
            path="$1"
            message="$2"
            cd "$path"
            num=$(git status --porcelain | wc -l)
            if [[ $num -ge 1 ]]; then            
                git add -A .
            fi
            num=$(git status --porcelain | wc -l)
            if [[ $num -ge 1 ]]; then
                git commit -m "$message ($num files)"
            fi
        }
        built_package_file() {
            # built_package_file <path>
            # echoes the full path of the last package (alphabetically) in path
            path="$1"
            find "$path" -maxdepth 1 -name \*.pkg.tar.xz | sort | tail -1            
        }
        pkgbuild_package_file() {
            # pkgbuild_package_file <path>
            # echoes the full path of the package a build will generate
            path="$1"
            pkgbuild="$path/PKGBUILD"
            ( 
                cd "$path"
                source_pkgbuild "$pkgbuild"
                fullver=$(get_full_version)
                pkgarch=$(get_pkg_arch)
                echo "$path/${pkgname}-${fullver}-${pkgarch}.pkg.tar.xz"
            )
        }
        pkgbuild_source_paths() {
            path="$1"
            pkgbuild="$path/PKGBUILD"
            (
                cd "$path"
                source_pkgbuild "$pkgbuild"
                for src in "${source[@]}"; do
                    echo "$src" | sed 's|^.*file://\(.*\)$|\1|'
                done 
            )
        }
        package_uptodate() {
            # package_uptodate <path>
            # Check whether the package is up to date.
            path="$1"
            pkgfile="$(pkgbuild_package_file $path)"
            if [ -z "$pkgfile" ]; then
                echo "An error occurred parsing the PKGBUILD"
                exit 1
            fi        
            [ -f  "$pkgfile" ]
        }
        builddir_path() {
            # builddir_path <path>
            # echoes the build directory path for a given package
            path="$1"
            pkgname=$(basename "$1")
            echo "$builddir/$pkgname"           
        }
        prepare_build() {
            # prepare_build <path>
            # Prepares a package for building on the builddir
            # returns the path where the building will occur
            path="$1"
            pkgbuild=$(builddir_path "$path")
            rsync -avz --exclude=.git "$path/" "$pkgbuild/" > /dev/null
            echo "$pkgbuild"            
        }
        package_build() {
            # package_build <path>
            # Build a package at the given directory.
            path="$1"
            cd "$path"
            makepkg -f --sign
        }
        package_download() {
            # package_download <path>
            # Download package sources.
            path="$1"
            cd "$path"
            makepkg --nobuild
        }
        package_install() {
            # package_install <path>
            # Install a package.
            path="$1"
            pkgname=$(basename "$path")
            pkgfile=$(pkgbuild_package_file "$path")
            if [ -f "$pkgfile" ]; then
                sudo pacman --noconfirm -U "file://$pkgfile"               
            fi             
        }
        package_install_deps() {
            # package_install_deps <path>
            # Install package deps.
            path="$1"
            cd "$path"
            makepkg -s
        }
        package_repoadd() {
            # package_repoadd <path>
            # Add package to the pacman repo and clean older versions of it.
            path="$1"
            tgtrepo="$2"
            pkgname=$(basename "$path")
            pkgfile=$(pkgbuild_package_file "$path")
            repodb=$(basename "$tgtrepo").db.tar.gz
            if [ -f "$pkgfile" ]; then
                # clean older packages
                rm -f $tgtrepo/$pkgname-*.pkg.tar.xz{,.sig}
                # copy package and signature
                cp "$pkgfile" "$tgtrepo/"
                cp "$pkgfile.sig" "$tgtrepo/"
                repo-add -n "$tgtrepo/$repodb" "$pkgfile"
            fi
        }
        aur_checkout() {
            # aur_checkout <pkgname>
            # Checkout a PKGBUILD from AUR
            pkgname="$1"
            cower -df --ignorerepo "$pkgname"
            cd "$pkgname" && git init && git add -A . && git commit -m 'Initial commit'
        }
        aur_update() {
            # aur_update <path>
            # Update git repo with last PKGBUILD from AUR.                                   
            path="$1"
            pkgname=$(basename "$1")
            # NOTE: only update on branch master, to preserve possible local changes.
            if [ ! "$(git symbolic-ref HEAD 2>/dev/null)" == 'refs/heads/master' ]; then
                echo "Not on branch master"
                return 1
            fi              
            cower -df --ignorerepo "$pkgname" -t ..
            commit_if_changes "$path" "Updated from AUR"
        }

build= 
        buildpath=$(prepare_build "$PWD")
        ( package_download "$buildpath" )  > /dev/null 2>&1 
        if package_uptodate "$buildpath"; then
            echo "Package is up to date. No need to rebuild."
        else
            package_build "$buildpath"
        fi

rebuild= 
        buildpath=$(builddir_path "$PWD")
        [ -d "$buildpath" ] && rm -Rf "$buildpath"
        buildpath=$(prepare_build "$PWD")        
        package_build "$buildpath"

install= 
        buildpath=$(builddir_path "$PWD")
        package_install "$buildpath"

installdeps=
        package_install_deps "$buildpath"

update=
        mr build
        mr repoadd
